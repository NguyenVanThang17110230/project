#!/usr/bin/env node
'use strict';

/*eslint no-process-exit:0 no-console:0*/
var console = require('console');
var process = require('process');
var through2 = require('through2');
var byline = require('byline');
var table = require('text-table');
var isTTY = process.stdout.isTTY;
var chalk = require('chalk');
var extend = require('xtend');
var fmt = require('util').format;
var argv = require('minimist')(process.argv.slice(2));

var hasErrors = false;

function CheckStyleReporter() {
    // ==== begin attribution ==================================================
    // The pairs object and encode function are borrowed from:
    // github.com/jshint/jshint src/reporters/checkstyle.js
    // Author: Boy Baukema, http://github.com/relaxnow
    // License MIT
    // This code should be replaced in a future commit of checkstyle-reporter.js
    var pairs = {
        '&': '&amp;',
        '"': '&quot;',
        '\'': '&apos;',
        '<': '&lt;',
        '>': '&gt;'
    };

    function encode(s) {
        for (var r in pairs) {
            if (typeof s !== 'undefined') {
                s = s.replace(new RegExp(r, 'g'), pairs[r]);
            }
        }
        return s || '';
    }
    // ==== end attribution ====================================================

    var errors = [];

    function printFile(fileErrors) {
        return fmt('\t<file name="%s">\n%s\n\t</file>',
            encode(fileErrors.file),
            fileErrors.errors.map(printError).join('\n')
        );
    }

    function printError(error) {
        return fmt(
            '\t\t<error line="%d" column="%d" severity="%s" ' +
            'message="%s" source="%s" />',
            error.line,
            error.column,
            'error',
            encode(error.message),
            encode(error.rule)
        );
    }

    function transform(fileErrors, enc, callback) {
        errors.push(fileErrors);
        callback();
    }

    function flush(callback) {
        var checkstyle = [
                '<?xml version="1.0" encoding="utf-8"?>',
                '<checkstyle version="4.3">',
                errors.map(printFile).join('\n'),
                '</checkstyle>'
            ].join('\n') + '\n';
        this.push(checkstyle);
        callback();
    }

    return through2.obj(transform, flush);
}

function StylishReporter(options) {
    var tableOptions = {
        align: ['l', 'r', 'l', 'l', 'l'],
        hsep: ''
    };

    function formatRow(error) {
        // pad number with spaces in front
        var line = ('    ' + error.line).slice(-4);
        // pad number with spaces behind
        var column = (error.column + '  ').slice(0, 3);
        var message = ' ' + error.message;
        var rule = error.rule;

        if (options.colors) {
            line = chalk.magenta(line);
            column = chalk.blue(column);
            message = chalk.white(message);
            rule = chalk.yellow(rule);
        }

        if (rule.length > 0) {
            message = message + ' (' + rule + ')';
        }

        return ['  ', line, ':', column, message];
    }

    function transform(fileErrors, enc, callback) {
        var file = fileErrors.file;
        var errors = fileErrors.errors.map(formatRow);
        var header = options.colors ? chalk.underline.cyan(file) : file;
        var formattedErrors = table(errors, tableOptions);
        this.push(header + '\n' + formattedErrors + '\n');
        callback();
    }

    return through2.obj(transform);
}

function JSONReporter() {
    var errors = {
        files: []
    };

    function transform(fileErrors, enc, callback) {
        errors.files.push(fileErrors);
        callback();
    }

    function flush(callback) {
        this.push(JSON.stringify(errors, undefined, 2) + '\n');
        callback();
    }

    return through2.obj(transform, flush);
}

function parseErrors() {
    function transform(chunk, enc, callback) {
        var parts = chunk.toString().split(':');
        if (parts.length !== 4) {
            return callback();
        }

        var message = parts[3].trim();
        var rule = '';

        if (message.lastIndexOf('(') !== -1) {
            var pos = message.lastIndexOf('(');
            rule = message.substring(pos + 1, message.length - 1);
            message = message.substring(0, pos);
        }

        this.push({
            type: 'error',
            file: parts[0].trim(),
            line: parts[1],
            column: parts[2],
            message: message.trim(),
            rule: rule
        });

        if (!hasErrors) {
            hasErrors = true;
        }

        callback();
    }

    return through2.obj(transform);
}

function groupErrorsByFile() {
    var errors = {};
    var currentFile = null;

    function transform(error, enc, callback) {
        if (errors[error.file]) {
            errors[error.file].push(error);
        } else {
            errors[error.file] = [error];
            if (currentFile && currentFile !== error.file) {
                this.push({
                    file: currentFile,
                    errors: errors[currentFile]
                });
            }
            currentFile = error.file;
        }

        callback();
    }

    function flush(callback) {
        if (currentFile) {
            this.push({
                type: 'file',
                file: currentFile,
                errors: errors[currentFile]
            });
        }
        callback();
    }

    return through2.obj(transform, flush);
}

var reporterMap = {
    'json': JSONReporter,
    'checkstyle': CheckStyleReporter,
    'stylish': StylishReporter
};

function standardReporter(options) {
    options = extend({
        type: 'none',
        colors: isTTY,
        sink: process.stdout
    }, options || {});

    var inputStream = through2(noopTransform);
    var reporter = reporterMap[options.type];

    if (reporter) {
        inputStream
            .pipe(byline())
            .pipe(parseErrors())
            .pipe(groupErrorsByFile())
            .pipe(reporter(options))
            .pipe(options.sink);
    } else {
        inputStream.pipe(options.sink);
    }

    function noopTransform(chunk, enc, callback) {
        this.push(chunk);
        callback();
    }

    return inputStream;
}

module.exports = standardReporter;

if (require.main === module) {
    var type = argv.json ? 'json' :
        argv.checkstyle ? 'checkstyle' :
            argv.stylish ? 'stylish' : 'none';

    process.stdin.pipe(standardReporter({
        type: type
    }));

    process.on('error', function handleError(err) {
        console.error(err);
        hasErrors = true;
    });

    process.on('exit', function onStandardExit() {
        if (hasErrors) {
            return process.exit(1);
        }
        process.exit(0);
    });
}
