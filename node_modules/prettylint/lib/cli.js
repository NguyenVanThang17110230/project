"use strict";
exports.__esModule = true;
var tslib_1 = require("tslib");
var fs = require("fs");
var globby = require("globby");
var ignore = require("ignore");
var meow = require("meow");
var path = require("path");
var lint_1 = require("./lint");
// tslint:disable-next-line:no-inferrable-types
exports.help_message = "\n  Usage\n    $ prettylint <glob> ...\n\n  Options\n    --no-config           Do not load config file.\n    --config <path>       Specify the config file. (require prettier@1.7.1+)\n    --fix                 Fix linting errors.\n    --format <path>       Specify the module to format output.\n                          Defaults to \"eslint-formatter-pretty\".\n    --ignore-path <path>  Specify the .ignore file.\n                          Defaults to \".prettierignore\".\n    --silent              Do not print message.\n    -h, --help            Show help.\n    -v, --version         Show version.\n\n  Examples\n    $ prettylint \"src/**/*.{js,ts}\"\n    $ prettylint \"src/**/*.{js,ts}\" --fix\n    $ prettylint \"src/**/*.{js,ts}\" --ignore-path .gitignore\n";
function run(argv) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _this = this;
        var _a, input, flags, ignorer, default_ignore_path, _b, _c, _d, _e, filenames, _f, _g, error_count, warning_count, results, formatter, message;
        return tslib_1.__generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _a = meow({
                        argv: argv,
                        version: true,
                        help: exports.help_message
                    }, {
                        alias: {
                            h: 'help',
                            v: 'version'
                        },
                        boolean: ['fix', 'silent'],
                        string: ['config', 'ignore-path', 'format'],
                        "default": {
                            fix: false,
                            format: 'eslint-formatter-pretty',
                            silent: false
                        }
                    }), input = _a.input, flags = _a.flags;
                    ignorer = ignore();
                    default_ignore_path = '.prettierignore';
                    if (!(flags.ignorePath === undefined)) return [3 /*break*/, 4];
                    if (!!fs.existsSync(default_ignore_path)) return [3 /*break*/, 1];
                    input.push('!**/node_modules/**');
                    return [3 /*break*/, 3];
                case 1:
                    _c = (_b = ignorer).add;
                    return [4 /*yield*/, read_file(default_ignore_path)];
                case 2:
                    _c.apply(_b, [_h.sent()]);
                    _h.label = 3;
                case 3: return [3 /*break*/, 6];
                case 4:
                    _e = (_d = ignorer).add;
                    return [4 /*yield*/, read_file(flags.ignorePath)];
                case 5:
                    _e.apply(_d, [_h.sent()]);
                    _h.label = 6;
                case 6:
                    _g = (_f = ignorer).filter;
                    return [4 /*yield*/, globby(input, { dot: true })];
                case 7:
                    filenames = _g.apply(_f, [(_h.sent()).map(function (filename) {
                            return path.relative('.', filename);
                        })]);
                    error_count = 0;
                    warning_count = 0;
                    return [4 /*yield*/, Promise.all(filenames.map(function (filename) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var content, result, output, new_result;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, read_file(filename)];
                                    case 1:
                                        content = _a.sent();
                                        return [4 /*yield*/, lint_1.lint(filename, content, { config: flags.config })];
                                    case 2:
                                        result = _a.sent();
                                        error_count += result.errorCount;
                                        warning_count += result.warningCount;
                                        if (result.output === undefined || !flags.fix) {
                                            return [2 /*return*/, result];
                                        }
                                        return [4 /*yield*/, write_file(filename, result.output)];
                                    case 3:
                                        _a.sent();
                                        output = result.output, new_result = tslib_1.__rest(result, ["output"]);
                                        return [2 /*return*/, tslib_1.__assign({}, new_result, { messages: [], warningCount: 0 })];
                                }
                            });
                        }); }))];
                case 8:
                    results = _h.sent();
                    if (!flags.silent) {
                        formatter = require(flags.format);
                        message = formatter(results);
                        if (message.length !== 0) {
                            // tslint:disable-next-line:no-console
                            console.log(message);
                        }
                    }
                    if (error_count !== 0 || (!flags.fix && warning_count !== 0)) {
                        process.exitCode = 1;
                    }
                    return [2 /*return*/, results];
            }
        });
    });
}
exports.run = run;
function read_file(filename) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    fs.readFile(filename, { encoding: 'utf8' }, function (error, data) {
                        // istanbul ignore if
                        // tslint:disable-next-line:strict-boolean-expressions
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(data);
                        }
                    });
                })];
        });
    });
}
function write_file(filename, content) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    fs.writeFile(filename, content, function (error) {
                        // istanbul ignore if
                        // tslint:disable-next-line:strict-boolean-expressions
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve();
                        }
                    });
                })];
        });
    });
}
